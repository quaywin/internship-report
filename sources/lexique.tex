\chapter{Lexique}

\section{Technologie JAVA}\label{lexique:JAVA_tech}
JAVA est le nom d'une technologie mise au point par Sun Microsystems qui permet de produire des logiciels indépendants de toute architecture matérielle. Cette technologie s'appuie sur différents éléments qui, par abus de langage, sont souvent tous appelés Java.

\section{Langage JAVA}\label{lexique:JAVA_lg}
Le Langage Java est un langage de programmation informatique orienté objet créé par James Gosling et Patrick Naughton employés de Sun Microsystems avec le soutien de Bill Joy (cofondateur de Sun Microsystems en 1982), présenté officiellement le 23 mai 1995 au SunWorld. Le langage Java a la particularité principale que les logiciels écrits avec ce dernier sont très facilement portables sur plusieurs systèmes d'exploitation tels que Unix, Microsoft Windows, Mac OS ou Linux avec peu ou pas de modification... C'est la plate-forme qui garantit la portabilité des applications développées en Java. Le langage reprend en grande partie la syntaxe du langage C++, très utilisé par les informaticiens. Néanmoins, Java a été épuré des concepts les plus subtils du C++ et à la fois les plus déroutants, tels que l'héritage multiple 	 l'embauche par Jim Blandy de Karl Fogel, qui travaillait déjà sur un nouveau gestionnaire de version. 

\section{Agile}\label{lexique:agile}
Les méthodes Agiles sont des procédures de conception de logiciel. Le client est impliqué au maximum dans le processus de conception. Ainsi, ces méthodes permettent une grande réactivité à ses demandes. Elles visent la réele satisfaction de son besoin. Le besoin réel du client est prioritaire aux termes du contrat de développement. La notion de méthode agile est née à travers un Manifeste Agile signé par 17 personnalités en 2001. La notion de méthode agile se limite actuellement aux méthodes ciblant le développement d'une application informatique. Cependant des pratiques de l'agilité sont utilisé dans la gestion de certains projets non-informatiques.

\section{eXtreme Programming}\label{lexique:XP}
L'eXtreme Programming (XP) est une méthode Agile(cf. \ref{lexique:agile} p.\pageref{lexique:agile}) a comme philosophie d'accepter le changement plutôt que de le supporter. XP prône les cycles de développement courts (1 à 2 semaines). Un Client XP(cf. \ref{lexique:clientXP} p.\pageref{lexique:clientXP}) permet d'avoir des retours rapides et de s'assurer que les exigences fonctionnelles soient bien comprises et implémentées. L'eXtreme Programming repose sur cinq valeurs :
\begin{itemize}
\item{La communication}
\item{La simplicité}
\item{Le feedback}
\item{Le courage}
\item{Le respect}
\end{itemize}

\section{Vélocité}\label{lexique:velocité}
La vélocité est une métrique qui permet de faire une estimation du temps que prendra une tâche. La vélocité est utilisée lors de la cotation des fiches. Une fois les fiches réalisées on peut mesurer la différence entre l'estimation et la réalité. Cela dit ce n'est qu'une métrique, même si elle donne un bon ordre d'idée sur l'écoulement du temps elle ne doit pas être considérée comme un objesctif en elle même.

\section{Itération}
Une itération a en général une durée de 1 à 2 semaines. Elle se termine par la livraison (mineure ou majeure) du programme. Une rétrospective permet de faire le bilan de l'itération passée. Il est très rare et peu souhaitable que la livraison d'une itération ne dégage pas de valeur pour les utilisateurs (en général testeurs).

\section{Intégration continue}\label{lexique:integrationContinue}
Lorsqu'une tâche est terminée, les modifications sont immédiatement intégrées dans le produit complet. On évite ainsi la surcharge de travail liée à l'intégration de tous les éléments avant la livraison. Les tests facilitent grandement cette intégration : quand tous les tests passent, l'intégration est terminée. 

\section{Programmation en binôme}\label{lexique:pairProgramming}
La programmation se fait par deux. Le premier appelé driver (ou pilote) tient le clavier. C'est lui qui va travailler sur la portion de code à écrire. Le second appelé partner (ou co-pilote) est là pour l'aider en suggérant de nouvelles possibilités ou en décelant d'éventuels problèmes. Les développeurs changent fréquemment de partenaire ce qui permet d'améliorer la connaissance collective de l'application et d'améliorer la communication au sein de l'équipe. 

\section{Tests unitaires}\label{lexique:testU}
En programmation informatique, le test unitaire est un procédé permettant de s'assurer du fonctionnement correct d'une partie déterminée d'un logiciel ou d'une portion d'un programme (appelée « unité »). Il s'agit pour le programmeur de tester un module, indépendamment du reste du programme, ceci afin de s'assurer qu'il répond aux spécifications fonctionnelles et qu'il fonctionne correctement en toutes circonstances. Cette vérification est considérée comme essentielle, en particulier dans les applications critiques.
\paragraph*{}
Elle s'accompagne couramment d'une vérification de la couverture de code, qui consiste à s'assurer que le test conduit à exécuter l'ensemble (ou une fraction déterminée) des instructions présentes dans le code à tester. L'ensemble des tests unitaires doit être rejoué après une modification du code afin de vérifier qu'il n'y a pas de régressions (l'apparition de nouveaux dysfonctionnements). 
\paragraph*{}
Dans les applications non critiques, l'écriture des tests unitaires a longtemps été considérée comme une tâche secondaire. Cependant, la méthode Extreme programming (XP) a remis les tests unitaires, appelés « tests du programmeur », au centre de l'activité de programmation. La méthode XP préconise d'écrire les tests en même temps, ou même avant la fonction à tester (Test Driven Development). Ceci permet de définir précisément l'interface du module à développer. En cas de découverte d'un bogue, on écrit la procédure de test qui reproduit le bogue. Après correction on relance le test, qui ne doit indiquer aucune erreur.

\section{Tests haut niveau}\label{lexique:testHL}
Contrairement aux tests unitaires, les tests haut niveau s'assurent qu'une fonctionalité est opérationelle dans sa globalité. Le resultat d'un opération d'un plus haut niveau d'abstration est donc testé.

\section{Spike}\label{lexique:spike}
Un spike est une recherche en général technologique portant sur un sujet tel que l'adoption d'une nouvelle bibliothèque,sur des directions possible à prendre pour une grosse fonctionalité... Elle se fait sur une durée déteriminée. À la fin du spike le binôme est amené découper la fiche de spike en différentes plus petites,cela amène souvent à une nouvelle cotation plus fine et un choix technologique.

\section{Tests fonctionnels}\label{lexique:testsFonctionnels}
À partir des scénarios définis par le client, l'équipe crée des procédures de test qui permettent de vérifier l'avancement du développement. Lorsque tous les tests fonctionnels passent, l'itération est terminée. Ces tests sont souvent automatisés mais ce n'est pas toujours possible.

\section{Refactoring}\label{lexique:refactoring}
La refactorisation, aussi appelé remaniement de code, (anglicisme venant de refactoring) est une opération de maintenance du code informatique. Elle consiste à retravailler le code source non pas pour ajouter une fonctionnalité supplémentaire au logiciel mais pour améliorer sa lisibilité, simplifier sa maintenance, ou changer sa généricité (on parle aussi de remaniement). Une traduction plus appropriée serait réusinage. C'est donc une technique qui s'approche de l'optimisation du code, même si les objectifs sont radicalement différents. 

\section{Lean}\label{lexique:lean}
Lean est une école de gestion d'entreprise. Le mot Lean signifie littéralement ``maigre'', ``sans gras''. En ce sens elle recherche à améliorer la productivité et la qualité et à éliminer le gaspillage. Cette école à ses origine au japon dans le système de production de Toyota (TPS).

\section{Serialisation}\label{lexique:serialisation}
En informatique, la sérialisation (de l'anglais américain serialization, le terme marshalling est souvent employé de façon synonyme) est un processus visant à encoder l'état d'une information qui est en mémoire sous la forme d'une suite d'informations plus petites (dites atomiques, voir l'étymologie de atome) le plus souvent des octets voire des bits. Cette suite pourra par exemple être utilisée pour la sauvegarde (persistance) ou le transport sur le réseau (proxy, RPC…). L'activité symétrique, visant à décoder cette suite pour créer une copie conforme de l'information d'origine, s'appelle la désérialisation (ou unmarshalling).

\section{IntelliJ IDEA}\label{lexique:IDEA}
IntelliJ IDEA est un environnement de développement JAVA qui permet entre autres la refactorisation de code. Il est adapté aux pratiques agiles grâce aux support des serveurs de controle de version (en particulier fusion des fichier avancée). Différents algorithmes rendent son utilisation pratique et agréable (copier/coller avec copie des imports, divers avertissements, formatage automatique de code, gestion des historiques subversion, ...)

\section{Client XP}\label{lexique:clientXP}
Appelé également client sur site, son rôle est de jouer l'interlocuteur au sein de l'équipe de développement. C'est en général un représentant du client, et il doit connaître les besoins des utilisateurs finaux. Il décide à chaque itération le fonctionnalité sur lesquelle l'équipe va travailler. Par le biais de discussions avec les développeurs, il s'assure que ce qui est développé correspond exactement aux besoins.

\section{Road-map}
La road-map est une planification des tâches à effectuer pour les différents jalons à venir. Elle donne les directions que l'entreprise prend pour l'avenir. Elle est créée par la mission produit qui est constituée du directeur de production, du client XP, d'un représentant des consultants, d'un représentant de la R\&D et d'un représentant des ventes.La road-map est élaborée lors d'un jeu de rôles (planning game). Et chaque fonctionnalité cotée gros grain (vision sur le moyen et long terme) est placée sur les différents jalons à venir. Ainsi une plannification sur le moyen et long terme (vision sur 3-4 jalons) est faite.

\section{Code contest}\label{lexique:codeContest}
C'est une challenge entre plusieurs équipes de programmeurs. Le but est de coder une petite application dans un temps limité sur un sujet précis. 
